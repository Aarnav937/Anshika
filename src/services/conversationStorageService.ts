/**
 * Conversation Storage Service
 * Manages conversations in IndexedDB with support for branching, tagging, and search
 */

import Dexie, { Table } from 'dexie';
import {
  Conversation,
  ConversationMetadata,
  ConversationFilter,
  ConversationSortOption,
  ConversationBranch,
  ConversationTag,
  DEFAULT_TAGS,
} from '../types/conversation';
import { Message } from '../types';

// IndexedDB Database
class ConversationDatabase extends Dexie {
  conversations!: Table<Conversation, string>;

  constructor() {
    super('ANSHIKA_Conversations');
    
    this.version(1).stores({
      conversations: 'id, title, createdAt, updatedAt, lastMessageAt, isArchived, isPinned, *tags',
    });
  }
}

const db = new ConversationDatabase();

/**
 * Generate unique conversation ID
 */
function generateConversationId(): string {
  return `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Generate unique branch ID
 */
function generateBranchId(): string {
  return `branch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Create a new conversation
 */
export async function createConversation(
  messages: Message[] = [],
  tags: ConversationTag[] = []
): Promise<Conversation> {
  const now = new Date();
  const mainBranchId = generateBranchId();
  
  const conversation: Conversation = {
    id: generateConversationId(),
    title: 'New Conversation',
    autoGeneratedTitle: undefined,
    customTitle: undefined,
    tags,
    messages,
    branches: [
      {
        id: mainBranchId,
        conversationId: '', // Will be set below
        parentBranchId: undefined,
        branchPointMessageIndex: 0,
        title: 'Main',
        createdAt: now,
        lastMessageAt: now,
        messageCount: messages.length,
      },
    ],
    currentBranchId: mainBranchId,
    createdAt: now,
    updatedAt: now,
    lastMessageAt: now,
    messageCount: messages.length,
    isArchived: false,
    isPinned: false,
  };

  // Set conversation ID in branch
  conversation.branches[0].conversationId = conversation.id;

  // Auto-generate title if there are messages
  if (messages.length > 0) {
    conversation.autoGeneratedTitle = generateTitleFromMessage(messages[0].content);
    conversation.title = conversation.autoGeneratedTitle;
  }

  await db.conversations.add(conversation);
  return conversation;
}

/**
 * Generate title from first message (simple version)
 */
function generateTitleFromMessage(content: string): string {
  // Take first 50 chars and clean up
  let title = content.trim().substring(0, 50);
  
  // Remove command prefix if present
  if (title.startsWith('/')) {
    title = title.substring(1);
  }
  
  // Capitalize first letter
  title = title.charAt(0).toUpperCase() + title.slice(1);
  
  // Add ellipsis if truncated
  if (content.length > 50) {
    title += '...';
  }
  
  return title || 'New Conversation';
}

/**
 * Get conversation by ID
 */
export async function getConversation(id: string): Promise<Conversation | undefined> {
  return await db.conversations.get(id);
}

/**
 * Update conversation
 */
export async function updateConversation(conversation: Conversation): Promise<void> {
  conversation.updatedAt = new Date();
  await db.conversations.put(conversation);
}

/**
 * Delete conversation
 */
export async function deleteConversation(id: string): Promise<void> {
  await db.conversations.delete(id);
}

/**
 * Get all conversations with filtering and sorting
 */
export async function getConversations(
  filter?: ConversationFilter,
  sort?: ConversationSortOption
): Promise<ConversationMetadata[]> {
  let query = db.conversations.toCollection();

  // Apply filters
  if (filter?.isArchived !== undefined) {
    query = query.filter(c => c.isArchived === filter.isArchived);
  }

  if (filter?.isPinned !== undefined) {
    query = query.filter(c => c.isPinned === filter.isPinned);
  }

  if (filter?.tags && filter.tags.length > 0) {
    query = query.filter(c => 
      c.tags.some(tag => filter.tags!.includes(tag.id))
    );
  }

  if (filter?.dateRange) {
    query = query.filter(c => {
      const date = c.lastMessageAt;
      return date >= filter.dateRange!.start && date <= filter.dateRange!.end;
    });
  }

  // Get results
  let conversations = await query.toArray();

  // Apply search query
  if (filter?.searchQuery) {
    const searchLower = filter.searchQuery.toLowerCase();
    conversations = conversations.filter(c => 
      c.title.toLowerCase().includes(searchLower) ||
      c.messages.some(m => m.content.toLowerCase().includes(searchLower))
    );
  }

  // Apply sorting
  if (sort) {
    conversations.sort((a, b) => {
      const aVal = a[sort.field];
      const bVal = b[sort.field];
      
      if (aVal < bVal) return sort.direction === 'asc' ? -1 : 1;
      if (aVal > bVal) return sort.direction === 'asc' ? 1 : -1;
      return 0;
    });
  } else {
    // Default sort by lastMessageAt descending
    conversations.sort((a, b) => b.lastMessageAt.getTime() - a.lastMessageAt.getTime());
  }

  // Convert to metadata
  return conversations.map(c => conversationToMetadata(c));
}

/**
 * Convert conversation to metadata
 */
function conversationToMetadata(conversation: Conversation): ConversationMetadata {
  return {
    id: conversation.id,
    title: conversation.title,
    tags: conversation.tags,
    createdAt: conversation.createdAt,
    updatedAt: conversation.updatedAt,
    lastMessageAt: conversation.lastMessageAt,
    messageCount: conversation.messageCount,
    branchCount: conversation.branches.length,
    isArchived: conversation.isArchived,
    isPinned: conversation.isPinned,
    firstMessagePreview: conversation.messages[0]?.content.substring(0, 100) || '',
  };
}

/**
 * Add message to conversation
 */
export async function addMessageToConversation(
  conversationId: string,
  message: Message
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  conversation.messages.push(message);
  conversation.messageCount = conversation.messages.length;
  conversation.lastMessageAt = new Date();

  // Update current branch
  const currentBranch = conversation.branches.find(b => b.id === conversation.currentBranchId);
  if (currentBranch) {
    currentBranch.messageCount++;
    currentBranch.lastMessageAt = new Date();
  }

  await updateConversation(conversation);
}

/**
 * Create a branch from a specific message
 */
export async function createBranch(
  conversationId: string,
  branchPointMessageIndex: number,
  branchTitle?: string
): Promise<ConversationBranch> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  const now = new Date();
  const newBranch: ConversationBranch = {
    id: generateBranchId(),
    conversationId,
    parentBranchId: conversation.currentBranchId,
    branchPointMessageIndex,
    title: branchTitle || `Branch ${conversation.branches.length + 1}`,
    createdAt: now,
    lastMessageAt: now,
    messageCount: conversation.messages.length - branchPointMessageIndex,
  };

  conversation.branches.push(newBranch);
  await updateConversation(conversation);

  return newBranch;
}

/**
 * Switch to a different branch
 */
export async function switchBranch(
  conversationId: string,
  branchId: string
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  const branch = conversation.branches.find(b => b.id === branchId);
  if (!branch) {
    throw new Error(`Branch ${branchId} not found`);
  }

  conversation.currentBranchId = branchId;
  await updateConversation(conversation);
}

/**
 * Update conversation title
 */
export async function updateConversationTitle(
  conversationId: string,
  title: string,
  isCustom: boolean = true
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  if (isCustom) {
    conversation.customTitle = title;
    conversation.title = title;
  } else {
    conversation.autoGeneratedTitle = title;
    if (!conversation.customTitle) {
      conversation.title = title;
    }
  }

  await updateConversation(conversation);
}

/**
 * Add tag to conversation
 */
export async function addTagToConversation(
  conversationId: string,
  tag: ConversationTag
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  // Check if tag already exists
  if (!conversation.tags.some(t => t.id === tag.id)) {
    conversation.tags.push(tag);
    await updateConversation(conversation);
  }
}

/**
 * Remove tag from conversation
 */
export async function removeTagFromConversation(
  conversationId: string,
  tagId: string
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  conversation.tags = conversation.tags.filter(t => t.id !== tagId);
  await updateConversation(conversation);
}

/**
 * Archive/Unarchive conversation
 */
export async function archiveConversation(
  conversationId: string,
  archive: boolean = true
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  conversation.isArchived = archive;
  await updateConversation(conversation);
}

/**
 * Pin/Unpin conversation
 */
export async function pinConversation(
  conversationId: string,
  pin: boolean = true
): Promise<void> {
  const conversation = await getConversation(conversationId);
  if (!conversation) {
    throw new Error(`Conversation ${conversationId} not found`);
  }

  conversation.isPinned = pin;
  await updateConversation(conversation);
}

/**
 * Get all available tags
 */
export function getAvailableTags(): ConversationTag[] {
  return [...DEFAULT_TAGS];
}

/**
 * Export conversation storage service
 */
export const conversationStorageService = {
  createConversation,
  getConversation,
  updateConversation,
  deleteConversation,
  getConversations,
  addMessageToConversation,
  createBranch,
  switchBranch,
  updateConversationTitle,
  addTagToConversation,
  removeTagFromConversation,
  archiveConversation,
  pinConversation,
  getAvailableTags,
};
